

input PipelineInput {
    id: String
}

input TriggerInput {
    executionId: String
}

input StagesInput {
    refId: String
}

input OutputsInput {
    Buildnumber: String
    GitBranch: String
    GitRepo: String
    JobNumber: String
    artifacts: [String]
    canaryimage: String
    startTime: Int
}

input StagesRelationshipInput {
    s1: String
    s2: String
}

type Mutation {
    createPipeline(input: PipelineInput): Pipeline @cypher(statement:
    "MERGE (p:Pipeline { id: input.id}) RETURN p")
    createTrigger(input: TriggerInput): Trigger @cypher(statement:
    "MERGE (t:Trigger { executionId: input.executionId}) RETURN t")
    createStages(input: StagesInput): Stages @cypher(statement:
    "MERGE (s:Stages { refId: input.refId}) RETURN s")
    createOutputs(input: OutputsInput): Outputs @cypher(statement:
    "MERGE (o:Outputs { JobNumber: input.JobNumber}) RETURN o")

    createStageTimeline(input: StagesRelationshipInput): Stages @cypher(statement:
    "MERGE (s1:Stages { refId: input.s1}) MERGE (s2:Stages { refId: input.s2}) MERGE (s1) - [:NEXT] -> (s2) RETURN s2")
    createStageTrigger(input: StagesRelationshipInput): Stages @cypher(statement:
    "MERGE (s1:Trigger { executionId: input.s1}) MERGE (s2:Stages { refId: input.s2}) MERGE (s1) - [:NEXT] -> (s2) RETURN s2")
    createPipelineTrigger(input: StagesRelationshipInput): Pipeline @cypher(statement:
    "MERGE (s1:Trigger { executionId: input.s1}) MERGE (s2:Pipeline {id: input.s2}) MERGE (s2) - [:NEXT] -> (s1) RETURN s2")
    createStageOutputs(input: StagesRelationshipInput): Stages @cypher(statement:
    "MERGE (s1:Stages { refId: input.s1}) MERGE (s2:Outputs { JobNumber: input.s2}) MERGE (s1) - [:OUTPUTS] -> (s2) RETURN s1")
}














type Movie {
  title: String
  released: Int
  tagline: String
  cast: [Person] @relation(name: "ACTED_IN", direction:IN)
  directors: [Person] @relation(name: "DIRECTED", direction:IN)
  writers: [Person] @relation(name: "WROTE", direction:IN)
  producers: [Person] @relation(name: "PRODUCED", direction:IN)
  critics: [Person] @relation(name: "REVIEWED", direction:IN)
    people: [Person] @relation(direction:IN)

type Pipelinefailed { text: String }

type Pipelinestarting { text: String }

type Pipelinecomplete { text: String }

type Message
{ pipelinefailed: Pipelinefailed
    pipelinestarting: Pipelinestarting
    pipelinecomplete: Pipelinecomplete
}

type Notifications { address: String
    level: String
    type: String
    when: [String]
    message: Message }

type Trigger { type: String
    user: String
    rebake: Boolean
    dryRun: Boolean
    strategy: Boolean
    executionId: String
    eventId: String
    enabled: Boolean
    preferred: Boolean
    expectedArtifacts: [String ]
    resolvedExpectedArtifacts: [String]
    notifications: [String ]
    artifacts: [String ]
    NextStage: [Stages] @relation(name: "NEXT_STAGE", direction:OUT)

}

type Authentication {
    user: String allowedAccounts: [String]

}

type Tasks { id: String
    implementingClass: String
    name: String
    startTime: Int
    endTime: Int
    status: String
    stageStart: Boolean
    stageEnd: Boolean
    loopStart: Boolean
    loopEnd: Boolean
}

type PropertyFileContents { GitRepo: String
    Buildnumber: String
    GitBranch: String
    JobNumber: String }

type Scm { name: String
    branch: String
    sha1: String
    remoteUrl: String
}

type Artifacts {
    fileName: String
    displayPath: String
    relativePath: String
    reference: String
    name: String
    type: String
    version: String
    decorated: Boolean

}

type BuildInfo {
    building: Boolean
    fullDisplayName: String
    name: String
    number: Int
    duration: Int
    timestamp: String
    result: String
    url: String
    id: String
    scm: [Scm] @relation(name: "SUPPLY_CHAIN_MANAGEMENT", direction:IN)
    artifacts: [Artifacts] @relation(name: "ARTIFACTS", direction:IN)
}

type Outputs {
    Buildnumber: String
    GitBranch: String
    GitRepo: String
    JobNumber: String
    artifacts: [String ]
    propertyFileContents: PropertyFileContents @relation(name: "GIT_INFO", direction:IN)
    buildInfo: BuildInfo @relation(name: "INFORMS_ABOUT", direction:IN)
}

type Context {
    propertyFile: String
    consecutiveErrors: Int
    queuedBuild: String
    Buildnumber: String
    GitBranch: String
    buildNumber: Int
    JobNumber: String
    master: String
    GitRepo: String
    failPipeline: Boolean
    job: String
    continuePipeline: Boolean
    propertyFileContents: PropertyFileContents @relation(name: "GIT_INFO", direction:IN)
    buildInfo: BuildInfo @relation(name: "INFORMS_ABOUT", direction:IN)
}

type Stages {
    id: String
    refId: String
    type: String
    name: String
    startTime: Int
    endTime: Int
    status: String
    requisiteStageRefIds: [String ]
    tasks: [Tasks] @relation(name: "REQUIRED_TASKS", direction:IN)
   outputs: Outputs @relation(name: "OUTPUTS", direction:OUT)
    context: Context @relation(name: "CONTEXTUALIZES", direction:IN)
    NextStage: [Stages] @relation(name: "NEXT_STAGE", direction:OUT)
}

type Pipeline {
    type: String
    id: String
    application: String
    name: String
    buildTime: Int
    canceled: Boolean
    limitConcurrent: Boolean
    keepWaitingPipelines: Boolean
    startTime: Int
    endTime: Int
    status: String
    origin: String
    pipelineConfigId: String
    spelEvaluator: String
    systemNotifications: [String ]
    notifications: [Notifications] @relation(name: "NOTIFIES", direction:IN)
    trigger: Trigger @relation(name: "TRIGGERS", direction:IN)
    authentication: Authentication @relation(name: "AUTHENTICATES", direction:IN)
    stages: [Stages] @relation(name: "STAGES", direction:IN)
}


