type metadata {
    generation: Float
    uid: String
    resourceVersion: String
    name: String
    namespace: String
    creationTimestamp: String
    annotations: annotations @relation(name: "", direction: IN)
    id: Float
    generateName: String
    account: String
    labels: labels @relation(name: "", direction: IN)
    
}

type connectors {
    connectorType: String
    helpText: String
    values: [values] @relation(name: "", direction: IN)
    supportedParams: [supportedParams] @relation(name: "", direction: IN)
    label: String
    isMultiSupported: Boolean
    
}

type kato_tasks {
    resultObjects: [resultObjects] @relation(name: "", direction: IN)
    id: Float
    history: [history] @relation(name: "", direction: IN)
    status: status @relation(name: "", direction: IN)
    
}

type securityContext {
    
}

type statusCategory {
    colorName: String
    name: String
    self: String
    id: Float
    key: String
    
}

type resolution {
    name: String
    self: String
    description: String
    id: Float
    
}

type context {
    deploy_account_name: String
    outputs_createdArtifacts: [outputs_createdArtifacts] @relation(name: "", direction: IN)
    propertyFile: String
    webhook: webhook @relation(name: "", direction: IN)
    queuedBuild: String
    namespaceOverride: String
    source: String
    buildNumber: Float
    JobNumber: String
    mode: String
    payload: String
    resolvedExpectedArtifacts: [resolvedExpectedArtifacts] @relation(name: "", direction: IN)
    kato_last_task_id: kato_last_task_id @relation(name: "", direction: IN)
    requiredArtifactIds: [String]
    requiredArtifacts: [requiredArtifacts] @relation(name: "", direction: IN)
    artifacts: [artifacts] @relation(name: "", direction: IN)
    parameterValues: parameterValues @relation(name: "", direction: IN)
    app: String
    method: String
    manifest_account_name: String
    kato_task_terminalRetryCount: Float
    statusUrlResolution: String
    kato_task_firstNotFoundRetry: Float
    failOnFailedExpressions: Boolean
    outputs_manifestNamesByNamespace: outputs_manifestNamesByNamespace @relation(name: "", direction: IN)
    messages: [messages] @relation(name: "", direction: IN)
    failedManifests: [failedManifests] @relation(name: "", direction: IN)
    kato_tasks: [kato_tasks] @relation(name: "", direction: IN)
    outputs_manifests: [outputs_manifests] @relation(name: "", direction: IN)
    deploy_jobs: deploy_jobs @relation(name: "", direction: IN)
    hosturl: String
    job: String
    parameters: parameters @relation(name: "", direction: IN)
    notification_type: String
    payloadConstraint: [String]
    jobStatus: jobStatus @relation(name: "", direction: IN)
    consecutiveErrors: Float
    terminalStatuses: String
    buildInfo: buildInfo @relation(name: "", direction: IN)
    credentials: String
    completionDetails: completionDetails @relation(name: "", direction: IN)
    statusEndpoint: String
    Buildnumber: String
    GitBranch: String
    consumeArtifactSource: String
    stableManifests: [stableManifests] @relation(name: "", direction: IN)
    GitRepo: String
    manifest_location: String
    cloudProvider: String
    kato_result_expected: Boolean
    manifest_name: String
    deploy_server_groups: deploy_server_groups @relation(name: "", direction: IN)
    trafficManagement: trafficManagement @relation(name: "", direction: IN)
    alias: String
    key: String
    customHeaders: customHeaders @relation(name: "", direction: IN)
    statusJsonPath: String
    expectedArtifacts: [expectedArtifacts] @relation(name: "", direction: IN)
    progressJsonPath: String
    variables: [variables] @relation(name: "", direction: IN)
    comments: Float
    replicas: Float
    manifest: manifest @relation(name: "", direction: IN)
    manifestName: String
    canceledStatuses: String
    moniker: moniker @relation(name: "", direction: IN)
    waitForCompletion: Boolean
    url: String
    master: String
    optionalArtifacts: [optionalArtifacts] @relation(name: "", direction: IN)
    application: String
    outputs_boundArtifacts: [outputs_boundArtifacts] @relation(name: "", direction: IN)
    successStatuses: String
    manifests: [manifests] @relation(name: "", direction: IN)
    report: String
    failPipeline: Boolean
    location: String
    kato_task_notFoundRetryCount: Float
    waitTime: Float
    account: String
    skipExpressionEvaluation: Boolean
    continuePipeline: Boolean
    propertyFileContents: propertyFileContents @relation(name: "", direction: IN)
    kato_task_lastStatus: String
    
}

type options {
    enableTraffic: Boolean
    services: Boolean
    
}

type state {
    terminated: terminated @relation(name: "", direction: IN)
    
}

type scm {
    sha1: String
    name: String
    remoteUrl: String
    branch: String
    
}

type tasks {
    stageStart: Boolean
    loopStart: Boolean
    stageEnd: Boolean
    name: String
    startTime: Float
    id: Float
    endTime: Float
    loopEnd: Boolean
    implementingClass: String
    status: status @relation(name: "", direction: IN)
    
}

type requiredArtifacts {
    customKind: Boolean
    reference: String
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    artifactAccount: String
    type: String
    
}

type matchLabels {
    app: String
    component: String
    controller_uid: String
    
}

type avatarUrls {
    48x48: String
    24x24: String
    16x16: String
    32x32: String
    
}

type volumes {
    configMap: configMap @relation(name: "", direction: IN)
    name: String
    
}

type priority {
    name: String
    self: String
    iconUrl: String
    id: Float
    
}

type labels {
    app: String
    app_kubernetes_io_managed_by: String
    component: String
    webhook: webhook @relation(name: "", direction: IN)
    job_name: String
    app_kubernetes_io_name: String
    version: String
    controller_uid: String
    
}

type outputs_manifests {
    metadata: metadata @relation(name: "", direction: IN)
    apiVersion: String
    kind: String
    spec: spec @relation(name: "", direction: IN)
    status: status @relation(name: "", direction: IN)
    
}

type assignee {
    accountId: String
    avatarUrls: avatarUrls @relation(name: "", direction: IN)
    displayName: String
    accountType: String
    self: String
    active: Boolean
    timeZone: String
    
}

type conditions {
    reason: String
    lastTransitionTime: Float
    message: message @relation(name: "", direction: IN)
    type: String
    lastUpdateTime: String
    status: status @relation(name: "", direction: IN)
    
}

type matchArtifact {
    customKind: Boolean
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    artifactAccount: String
    id: Float
    type: String
    
}

type deploy_server_groups {
    
}

type notifications {
    address: String
    level: String
    message: message @relation(name: "", direction: IN)
    type: String
    when: [String]
    
}

type status {
    retryable: Boolean
    phase: String
    containerStatuses: [containerStatuses] @relation(name: "", direction: IN)
    hostIP: String
    replicas: Float
    readyReplicas: Float
    description: String
    completed: Boolean
    failed: Boolean
    statusCategory: statusCategory @relation(name: "", direction: IN)
    updatedReplicas: Float
    availableReplicas: Float
    podIPs: [podIPs] @relation(name: "", direction: IN)
    podIP: String
    loadBalancer: loadBalancer @relation(name: "", direction: IN)
    name: String
    self: String
    startTime: Float
    qosClass: String
    iconUrl: String
    id: Float
    conditions: [conditions] @relation(name: "", direction: IN)
    observedGeneration: Float
    
}

type template {
    metadata: metadata @relation(name: "", direction: IN)
    spec: spec @relation(name: "", direction: IN)
    
}

type jobStatus {
    provider: String
    completionDetails: completionDetails @relation(name: "", direction: IN)
    jobState: String
    name: String
    createdTime: Float
    location: String
    pods: [pods] @relation(name: "", direction: IN)
    account: String
    
}

type buildInfo {
    duration: Float
    result: String
    number: Float
    name: String
    fullDisplayName: String
    id: Float
    scm: [scm] @relation(name: "", direction: IN)
    building: Boolean
    url: String
    timestamp: String
    artifacts: [artifacts] @relation(name: "", direction: IN)
    
}

type pipeline_failed {
    text: String
    
}

type createdArtifacts {
    customKind: Boolean
    reference: String
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    location: String
    type: String
    version: String
    
}

type ports {
    protocol: String
    port: Float
    name: String
    containerPort: Float
    targetPort: Float
    
}

type secretKeyRef {
    name: String
    key: String
    
}

type deploy_jobs {
    default: [String]
    
}

type trafficManagement {
    options: options @relation(name: "", direction: IN)
    enabled: Boolean
    
}

type variables {
    sourceValue: String
    value: Float
    key: String
    
}

type creator {
    accountId: String
    emailAddress: String
    avatarUrls: avatarUrls @relation(name: "", direction: IN)
    displayName: String
    accountType: String
    self: String
    active: Boolean
    timeZone: String
    
}

type reporter {
    accountId: String
    emailAddress: String
    avatarUrls: avatarUrls @relation(name: "", direction: IN)
    displayName: String
    accountType: String
    self: String
    active: Boolean
    timeZone: String
    
}

type trigger {
    expectedArtifacts: [expectedArtifacts] @relation(name: "", direction: IN)
    eventId: String
    dryRun: Boolean
    rebake: Boolean
    type: String
    enabled: Boolean
    executionId: String
    resolvedExpectedArtifacts: [resolvedExpectedArtifacts] @relation(name: "", direction: IN)
    strategy: strategy @relation(name: "", direction: IN)
    user: String
    parameters: parameters @relation(name: "", direction: IN)
    notifications: [notifications] @relation(name: "", direction: IN)
    preferred: Boolean
    artifacts: [artifacts] @relation(name: "", direction: IN)
    
}

type aggregateprogress {
    total: Float
    progress: Float
    
}

type Pipeline {
    keepWaitingPipelines: Boolean
    pipelineConfigId: String
    systemNotifications: String
    buildTime: Float
    spelEvaluator: String
    origin: String
    trigger: trigger @relation(name: "", direction: IN)
    type: String
    canceled: Boolean
    limitConcurrent: Boolean
    application: String
    initialConfig: initialConfig @relation(name: "", direction: IN)
    name: String
    stages: [stages] @relation(name: "", direction: IN)
    startTime: Float
    id: Float
    endTime: Float
    notifications: [notifications] @relation(name: "", direction: IN)
    status: status @relation(name: "", direction: IN)
    authentication: authentication @relation(name: "", direction: IN)
    
}

type customfield_10315 {
    hasEpicLinkFieldDependency: Boolean
    showField: Boolean
    nonEditableReason: nonEditableReason @relation(name: "", direction: IN)
    
}

type manifests {
    metadata: metadata @relation(name: "", direction: IN)
    apiVersion: String
    kind: String
    spec: spec @relation(name: "", direction: IN)
    status: status @relation(name: "", direction: IN)
    
}

type outputs_boundArtifacts {
    customKind: Boolean
    reference: String
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    artifactAccount: String
    type: String
    
}

type progress {
    total: Float
    progress: Float
    
}

type supportedParams {
    helpText: String
    name: String
    label: String
    type: String
    
}

type votes {
    hasVoted: Boolean
    self: String
    votes: Float
    
}

type worklog {
    total: Float
    maxResults: Float
    startAt: Float
    worklogs: Float
    
}

type propertyFileContents {
    GitRepo: String
    Buildnumber: String
    report: String
    GitBranch: String
    hosturl: String
    JobNumber: String
    key: String
    
}

type outputs {
    outputs_createdArtifacts: [outputs_createdArtifacts] @relation(name: "", direction: IN)
    reason: String
    jobStatus: jobStatus @relation(name: "", direction: IN)
    buildInfo: buildInfo @relation(name: "", direction: IN)
    completionDetails: completionDetails @relation(name: "", direction: IN)
    Buildnumber: String
    GitBranch: String
    bimage: String
    JobNumber: String
    prodimage: String
    canaryReportURL: String
    GitRepo: String
    resolvedExpectedArtifacts: [resolvedExpectedArtifacts] @relation(name: "", direction: IN)
    startTime: Float
    key: String
    artifacts: [artifacts] @relation(name: "", direction: IN)
    requiredArtifacts: [requiredArtifacts] @relation(name: "", direction: IN)
    executedBy: String
    comments: Float
    manifest: manifest @relation(name: "", direction: IN)
    overallScore: Float
    navigationalURL: String
    trigger: trigger @relation(name: "", direction: IN)
    overallResult: String
    message: message @relation(name: "", direction: IN)
    trigger_json: String
    cimage: String
    outputs_manifestNamesByNamespace: outputs_manifestNamesByNamespace @relation(name: "", direction: IN)
    optionalArtifacts: [optionalArtifacts] @relation(name: "", direction: IN)
    outputs_boundArtifacts: [outputs_boundArtifacts] @relation(name: "", direction: IN)
    manifests: [manifests] @relation(name: "", direction: IN)
    report: String
    canaryimage: String
    outputs_manifests: [outputs_manifests] @relation(name: "", direction: IN)
    hosturl: String
    location: String
    propertyFileContents: propertyFileContents @relation(name: "", direction: IN)
    status: status @relation(name: "", direction: IN)
    
}

type issuetype {
    avatarId: Float
    hierarchyLevel: Float
    name: String
    self: String
    description: String
    entityId: String
    id: Float
    iconUrl: String
    subtask: Boolean
    
}

type webhook {
    headers: headers @relation(name: "", direction: IN)
    statusEndpoint: String
    statusCodeValue: Float
    monitor: monitor @relation(name: "", direction: IN)
    body: body @relation(name: "", direction: IN)
    statusCode: String
    
}

type pipeline_complete {
    text: String
    
}

type nonEditableReason {
    reason: String
    message: message @relation(name: "", direction: IN)
    
}

type annotations {
    artifact_spinnaker_io_name: String
    strategy_spinnaker_io_max_version_history: String
    prometheus_io_path: String
    strategy_spinnaker_io_recreate: String
    prometheus_io_port: String
    deployment_kubernetes_io_revision: String
    artifact_spinnaker_io_type: String
    artifact_spinnaker_io_version: String
    cloud_google_com_neg: String
    strategy_spinnaker_io_versioned: String
    artifact_spinnaker_io_location: String
    prometheus_io_scrape: String
    kubectl_kubernetes_io_last_applied_configuration: String
    moniker_spinnaker_io_cluster: String
    moniker_spinnaker_io_application: String
    
}

type project {
    simplified: Boolean
    avatarUrls: avatarUrls @relation(name: "", direction: IN)
    name: String
    self: String
    id: Float
    projectTypeKey: String
    key: String
    
}

type manifestNamesByNamespace {
    default: [String]
    deploy_prod: [String]
    deploy_qa: [String]
    
}

type body {
    expand: String
    self: String
    id: Float
    fields: fields @relation(name: "", direction: IN)
    key: String
    
}

type spec {
    template: template @relation(name: "", direction: IN)
    dnsPolicy: String
    clusterIPs: [String]
    terminationGracePeriodSeconds: Float
    ipFamilyPolicy: String
    backoffLimit: Float
    replicas: Float
    parallelism: Float
    sessionAffinity: String
    volumes: [volumes] @relation(name: "", direction: IN)
    completions: Float
    securityContext: securityContext @relation(name: "", direction: IN)
    ports: [ports] @relation(name: "", direction: IN)
    type: String
    restartPolicy: String
    ttlSecondsAfterFinished: Float
    ipFamilies: [String]
    containers: [containers] @relation(name: "", direction: IN)
    revisionHistoryLimit: Float
    selector: selector @relation(name: "", direction: IN)
    strategy: strategy @relation(name: "", direction: IN)
    schedulerName: String
    progressDeadlineSeconds: Float
    clusterIP: String
    
}

type volumeMounts {
    mountPath: String
    name: String
    subPath: String
    
}

type resolvedExpectedArtifacts {
    usePriorArtifact: Boolean
    useDefaultArtifact: Boolean
    defaultArtifact: defaultArtifact @relation(name: "", direction: IN)
    id: Float
    boundArtifact: boundArtifact @relation(name: "", direction: IN)
    matchArtifact: matchArtifact @relation(name: "", direction: IN)
    
}

type kato_last_task_id {
    id: Float
    
}

type artifacts {
    reference: String
    customKind: Boolean
    fileName: String
    metadata: metadata @relation(name: "", direction: IN)
    relativePath: String
    name: String
    location: String
    displayPath: String
    type: String
    version: String
    decorated: Boolean
    
}

type parameterValues {
    summary: String
    cancel: String
    issuetype: issuetype @relation(name: "", direction: IN)
    issue: String
    success: String
    description: String
    terminate: String
    projectid: String
    retry: String
    
}

type issuerestriction {
    issuerestrictions: issuerestrictions @relation(name: "", direction: IN)
    shouldDisplay: Boolean
    
}

type watches {
    self: String
    isWatching: Boolean
    watchCount: Float
    
}

type containerStatuses {
    image: String
    imageID: String
    restartCount: Float
    ready: Boolean
    name: String
    started: Boolean
    state: state @relation(name: "", direction: IN)
    containerID: String
    lastState: lastState @relation(name: "", direction: IN)
    
}

type history {
    phase: String
    status: status @relation(name: "", direction: IN)
    
}

type podIPs {
    ip: String
    
}

type configMap {
    defaultMode: Float
    name: String
    
}

type containers {
    args: [String]
    image: String
    imagePullPolicy: String
    terminationMessagePolicy: String
    terminationMessagePath: String
    name: String
    resources: resources @relation(name: "", direction: IN)
    ports: [ports] @relation(name: "", direction: IN)
    env: [env] @relation(name: "", direction: IN)
    command: [String]
    volumeMounts: [volumeMounts] @relation(name: "", direction: IN)
    
}

type fields {
    statuscategorychangedate: String
    issuetype: issuetype @relation(name: "", direction: IN)
    components: components @relation(name: "", direction: IN)
    project: project @relation(name: "", direction: IN)
    description: String
    customfield_10373: String
    fixVersions: String
    resolution: resolution @relation(name: "", direction: IN)
    timetracking: timetracking @relation(name: "", direction: IN)
    customfield_10105: String
    attachment: String
    resolutiondate: String
    workratio: Float
    summary: String
    issuerestriction: issuerestriction @relation(name: "", direction: IN)
    watches: watches @relation(name: "", direction: IN)
    creator: creator @relation(name: "", direction: IN)
    subtasks: subtasks @relation(name: "", direction: IN)
    created: String
    reporter: reporter @relation(name: "", direction: IN)
    aggregateprogress: aggregateprogress @relation(name: "", direction: IN)
    priority: priority @relation(name: "", direction: IN)
    customfield_10344: customfield_10344 @relation(name: "", direction: IN)
    customfield_10300: String
    labels: labels @relation(name: "", direction: IN)
    customfield_10315: customfield_10315 @relation(name: "", direction: IN)
    customfield_10317: String
    versions: versions @relation(name: "", direction: IN)
    progress: Float
    issuelinks: issuelinks @relation(name: "", direction: IN)
    votes: Float
    comment: comment @relation(name: "", direction: IN)
    assignee: assignee @relation(name: "", direction: IN)
    worklog: worklog @relation(name: "", direction: IN)
    updated: String
    status: status @relation(name: "", direction: IN)
    
}

type parameters {
    connectors: [connectors] @relation(name: "", direction: IN)
    loadtime: String
    canarystarttime: Float
    log: String
    lifetime: String
    baselinestarttime: Float
    minicanaryresult: String
    serviceip: String
    policyurl: String
    metric: String
    payload: String
    canaryresultscore: String
    gate: String
    gateUrl: String
    gateurl: String
    imageids: String
    imageIds: String
    policypath: String
    
}

type completionDetails {
    reason: String
    exitCode: Float
    message: message @relation(name: "", direction: IN)
    signal: String
    
}

type values {
    artifact: String
    projectKey: String
    jira_ticket_no: String
    buildId: String
    job: String
    branch: String
    
}

type outputs_manifestNamesByNamespace {
    default: [String]
    deploy_prod: [String]
    deploy_qa: [String]
    
}

type lastState {
    
}

type boundArtifacts {
    customKind: Boolean
    reference: String
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    artifactAccount: String
    type: String
    
}

type timetracking {
    
}

type outputs_createdArtifacts {
    customKind: Boolean
    reference: String
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    location: String
    type: String
    version: String
    
}

type stableManifests {
    manifestName: String
    location: String
    
}

type pipeline_starting {
    text: String
    
}

type loadBalancer {
    
}

type resultObjects {
    createdArtifacts: [createdArtifacts] @relation(name: "", direction: IN)
    deployedNamesByLocation: deployedNamesByLocation @relation(name: "", direction: IN)
    manifests: [manifests] @relation(name: "", direction: IN)
    manifestNamesByNamespace: manifestNamesByNamespace @relation(name: "", direction: IN)
    boundArtifacts: [boundArtifacts] @relation(name: "", direction: IN)
    
}

type selector {
    app: String
    matchLabels: matchLabels @relation(name: "", direction: IN)
    
}

type rollingUpdate {
    maxSurge: String
    maxUnavailable: String
    
}

type terminated {
    reason: String
    exitCode: Float
    startedAt: Float
    containerID: String
    finishedAt: Float
    
}

type customHeaders {
    Authorization: [String]
    Content_Type: [String]
    
}

type authentication {
    allowedAccounts: [String]
    user: String
    
}

type expectedArtifacts {
    usePriorArtifact: Boolean
    displayName: String
    useDefaultArtifact: Boolean
    defaultArtifact: defaultArtifact @relation(name: "", direction: IN)
    id: Float
    matchArtifact: matchArtifact @relation(name: "", direction: IN)
    
}

type issuerestrictions {
    
}

type headers {
    date: String
    server: String
    x_envoy_upstream_service_time: String
    vary: String
    expect_ct: String
    strict_transport_security: String
    atl_traceid: String
    set_cookie: String
    nel: String
    x_content_type_options: String
    x_xss_protection: String
    x_arequestid: String
    content_type: String
    x_aaccountid: String
    report_to: String
    timing_allow_origin: String
    cache_control: String
    
}

type manifest {
    metadata: metadata @relation(name: "", direction: IN)
    apiVersion: String
    kind: String
    spec: spec @relation(name: "", direction: IN)
    status: status @relation(name: "", direction: IN)
    
}

type resources {
    
}

type defaultArtifact {
    customKind: Boolean
    metadata: metadata @relation(name: "", direction: IN)
    id: Float
    
}

type monitor {
    headers: headers @relation(name: "", direction: IN)
    statusCodeValue: Float
    body: body @relation(name: "", direction: IN)
    statusCode: String
    progressMessage: String
    
}

type moniker {
    app: String
    
}

type boundArtifact {
    customKind: Boolean
    reference: String
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    type: String
    
}

type env {
    name: String
    value: Float
    valueFrom: valueFrom @relation(name: "", direction: IN)
    
}

type message {
    pipeline_complete: pipeline_complete @relation(name: "", direction: IN)
    pipeline_starting: pipeline_starting @relation(name: "", direction: IN)
    pipeline_failed: pipeline_failed @relation(name: "", direction: IN)
    
}

type valueFrom {
    secretKeyRef: secretKeyRef @relation(name: "", direction: IN)
    
}

type optionalArtifacts {
    customKind: Boolean
    reference: String
    metadata: metadata @relation(name: "", direction: IN)
    name: String
    location: String
    type: String
    version: String
    
}

type initialConfig {
    
}

type deployedNamesByLocation {
    default: [String]
    
}

type stages {
    nextStage: stages @relation(name: "NEXT_STAGE", direction: OUT)
    outputs: outputs @relation(name: "OUTPUTS", direction: OUT)
    requisiteStageRefIds: [String]
    name: String
    context: context @relation(name: "CONTEXTUALIZES", direction: OUT)
    startTime: Float
    id: Float
    refId: String
    endTime: Float
    type: String
    tasks: [tasks] @relation(name: "REQUIRED_TASKS", direction: OUT)
    status: status @relation(name: "STATUS", direction: OUT)
    
}

type pods {
    name: String
    status: status @relation(name: "", direction: IN)
    
}

type comment {
    total: Float
    comments: Float
    maxResults: Float
    self: String
    startAt: Float
    
}

type strategy {
    type: String
    rollingUpdate: rollingUpdate @relation(name: "", direction: IN)
    
}

